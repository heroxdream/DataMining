trainSize = 350
testSize = totalInstance - trainSize
trainIndex = sample(1:522, 350)
trainSet = all.data[trainIndex, c(-1, -10)]
validateSet = all.data[-trainIndex, c(-1, -10)]
library(tree)
tree.realEstate = tree(binQua~., trainSet)
summary(tree.realEstate)
\color{red}{a}
load('realEstate.RData')
binQua = ifelse(realEstate$Quality == 1, 1, 0)
binQua = as.factor(binQua)
all.data = data.frame(realEstate, binQua)
totalInstance = dim(realEstate)[1]
trainSize = 350
testSize = totalInstance - trainSize
trainIndex = sample(1:522, 350)
trainSet = all.data[trainIndex, c(-1, -10)]
validateSet = all.data[-trainIndex, c(-1, -10)]
@
library(tree)
tree.realEstate = tree(binQua~., trainSet)
summary(tree.realEstate)
tree.realEstate
tree.realEstate
load('realEstate.RData')
binQua = ifelse(realEstate$Quality == 1, 1, 0)
binQua = as.factor(binQua)
all.data = data.frame(realEstate, binQua)
totalInstance = dim(realEstate)[1]
trainSize = 350
testSize = totalInstance - trainSize
set.seed(1)
trainIndex = sample(1:522, 350)
trainSet = all.data[trainIndex, c(-1, -10)]
validateSet = all.data[-trainIndex, c(-1, -10)]
library(tree)
tree.realEstate = tree(binQua~., trainSet)
summary(tree.realEstate)
tree.realEstate
plot(tree.realEstate)
text(tree.realEstate, pretty = 0)
?text
tree.pred = predict(tree.realEstate, validateSet, type = 'class')
table(tree.pred, validateSet$binQua)
(152 + 10) / 172
1 - (152 + 10) / 172
cv.realEstate = cv.tree(tree.realEstate, FUN = prune.misclass)
plot(cv.realEstate$size, cv.realEstate$dev, type = 'b')
plot(cv.realEstate$size, cv.realEstate$dev, type = 'b', col = 'red')
cv.realEstate$dev
cv.realEstate$size
prune.realEstate = prune.misclass(tree.realEstate, best = 6)
?prune.misclass
prune.realEstate = prune.misclass(tree.realEstate, best = 6, newdata = trainSet)
prune.realEstate
prune.pred.train = predict(prune.realEstate, trainSet, type = 'class')
table(prune.pred.train, trainSet$binQua)
summary(prune.pred.train)
1 - (295 + 46) / 350
prune.pred.validate = predict(prune.realEstate, validateSet, type = 'class')
table(prune.pred.validate, validateSet$binQua)
1 - (148 + 11) / 172
install.packages("raindomForest")
install.packages("randomForest")
?randomForest
??randomForest
?randomForest
library(randomForest)
bag.realEstate = randomForest(binQua ~ ., data = trainSet, mtry = 12, importance = T, ntree = 20)
bag.realEstate = randomForest(binQua ~ ., data = trainSet, mtry = 11, importance = T, ntree = 20)
bag.realEstate
summary(tree.realEstate)
table(tree.pred, validateSet$binQua)
(6 + 4) / 172
table(prune.pred.train, trainSet$binQua)
(6 + 3) / 350
table(prune.pred.validate, validateSet$binQua)
(8 + 5) / 172
bag.realEstate
varImpPlot(bag.realEstate)
?varImpPlot
varImpPlot(bag.realEstate, col = 'blue')
yhat.bag = predict(bag.realEstate, newdata = validateSet)
yhat.bag
table(yhat.bag, validateSet$binQua)
(3 + 5) / 172
set.seed(1)
forest.realEstate = randomForest(binQua ~ ., data = trainSet, importance = T, ntree = 100)
forest.realEstate
varImpPlot(forest.realEstate, col = 'blue')
yhat.forest = predict(forest.realEstate, newdata = validateSet)
table(yhat.forest, validateSet$binQua)
(3 + 5) / 172
(5 + 11) / 350
(4 + 7) / 172
(6 + 4) / 172
(4 + 3) / 172
install.packages("gbm")
shirinkages = seq(from = 0, to = 0.1, by = 0.02)
shirinkages
shirinkages = seq(from = 0, to = 1, by = 0.02)
shirinkages
trainErrors = rep(NA, length(shirinkages))
library(gbm)
boost.realEstate = gbm(binQua ~ ., trainSet, n.trees = 1000, interaction.depth = 3, verbose = F)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000, interaction.depth = 3, verbose = F)
summary(boost.realEstate)
boost.realEstate
summary(boost.realEstate)
a
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000, interaction.depth = 1, verbose = F)
summary(boost.realEstate)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000, interaction.depth = 4, verbose = F)
summary(boost.realEstate)
boost.realEstate$train.error
boost.realEstate$initF
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000, interaction.depth = 4)
summary(boost.realEstate)
boost.realEstate$c.splits
boost.realEstate$valid.error
boost.realEstate = gbm(binQua ~ ., distribution = 'ber' data = trainSet, n.trees = 1000, interaction.depth = 4)
boost.realEstate = gbm(binQua ~ ., distribution = 'ber', data = trainSet, n.trees = 1000, interaction.depth = 4)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000, interaction.depth = 4)
summary(boost.realEstate)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
library(gbm)
set.seed(1)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 1000)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
library(MASS)
boost.boston = gbm(medv ~., data = Boston, distribution = "guassian", n.trees = 5000, interaction.depth = 4)
boost.boston = gbm(medv ~., data = Boston, distribution = "guassian", n.trees = 5000, interaction.depth = 4)
Boston
summarise(Boston)
summary(Boston)
boost.boston = gbm(medv ~ . , data = Boston, distribution = "guassian", n.trees = 5000, interaction.depth = 4)
boost.boston = gbm(medv ~ . , data = Boston, distribution = "gaussian", n.trees = 5000, interaction.depth = 4)
summary(boost.boston)
boost.realEstate = gbm(binQua ~ ., data = trainSet, n.trees = 5000)
summary(boost.realEstate)
boost.realEstate = gbm(binQua ~ ., distribution = "bernoulli", data = trainSet, n.trees = 5000)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., distribution = "bernoulli", n.trees = 5000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 5000)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, n.cores = 4, verbose = "CV")
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "adaboost", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "gaussian", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "laplace", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "huberized", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
yhat.boost
class(yhat.boost)
yhat.boost[0]
yhat.boost[1]
yhat.boost[2]
yhat.boost[1,1,]
yhat.boost[1,1]
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "adaboost", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
yhat.boost
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'class')
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "adaboost", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'class')
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'link')
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'link')
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'class')
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'reponse')
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "adaboost", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "gaussian", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost
boost.realEstate = gbm.fit(binQua ~ ., data = trainSet, distribution = "gaussian", n.trees = 1000, n.cores = 4)
yhat.boost = ifelse(yhat.boost.array[1] > yhat.boost.array[0], 0, 1)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[1] > yhat.boost.array[0], 0, 1)
yhat.boost
yhat.boost.array
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[1] > yhat.boost.array[0], 0, 1)
yhat.boost
yhat.boost.array
yhat.boost.array[1,]
yhat.boost.array[1]
yhat.boost.array[2]
yhat.boost.array[1,1]
yhat.boost.array[,1]
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000)
yhat.boost = ifelse(yhat.boost.array[1] > yhat.boost.array[0], 0, 1)
yhat.boost.array
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'res')
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
head (yhat.boost.array)
yhat.boost.array
dim(yhat.boost.array)
yhat.boost.array[1,1,1]
yhat.boost.array[1,1,2]
yhat.boost.array[1,2,1]
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
yhat.boost
confusion(yhat.boost, validateSet$binQua)
??confusion
confusion
confusion()
table(yhat.boost, validateSet$binQua)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
summary(boost.realEstate)
boost.realEstate = gbm.git(x = trainSet, y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
require(gbm)
boost.realEstate = gbm.git(x = trainSet, y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
boost.realEstate = gbm.fit(x = trainSet, y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000, n.cores = 4)
boost.realEstate = gbm.fit(x = trainSet, y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000)
summary(boost.realEstate)
boost.realEstate = gbm.fit(x = trainSet[, -12], y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000)
boost.realEstate = gbm.fit(x = trainSet[, -12], y=trainSet$binQua, distribution = "bernoulli", n.trees = 1000)
summary(boost.realEstate)
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 1, by = 0.02)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
for (i in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000)
summary(boost.realEstate)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
test.correct.rate = yhat.boost == validateSet$binQua / len(validateSet$binQua)
train.correct.rate = sum(yhat.boost == trainSet$binQua) / len(trainSet$binQua)
trainAccu[i] = train.correct.rate
testAccu[i] = test.correct.rate
}
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 1, by = 0.02)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
for (i in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000)
# summary(boost.realEstate)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
test.correct.rate = yhat.boost == validateSet$binQua / length(validateSet$binQua)
train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
trainAccu[i] = train.correct.rate
testAccu[i] = test.correct.rate
}
warnings()
?gbm
set.seed(1)
shirinkages = seq(from = 0, to = 1, by = 0.02)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
# summary(boost.realEstate)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
test.correct.rate = yhat.boost == validateSet$binQua / length(validateSet$binQua)
train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
or (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = yhat.boost == validateSet$binQua / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = yhat.boost == validateSet$binQua / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
test.correct.rate = yhat.boost == validateSet$binQua / length(validateSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
test.correct.rate
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000)
boost.realEstate
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost.array
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
test.correct.rate
yhat.boost == validateSet$binQua
yhat.boost
yhat.boost.array[,1,1] > yhat.boost.array[,2,1]
yhat.boost.array[,1,1]
yhat.boost.array
yhat.boost.array[1,1,1] > yhat.boost.array[1,2,1]
yhat.boost.array[,1,1]
yhat.boost.array
dim(yhat.boost.array)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
dim(yhat.boost.array)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, verbose = T)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "adaboost", n.trees = 1000, verbose = T)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost.array
summary(yhat.boost.array)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000, verbose = T)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "bernoulli", n.trees = 1000)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
dim(yhat.boost.array)
yhat.boost.array
class(yhat.boost.array)
yhat.boost.array[1]
yhat.boost.array[2]
yhat.boost.array[170]
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
test.correct.rate
yhat.boost.array
yhat.boost
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
shirinkages
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
testAccu
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 1, by = 0.1)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
testAccu
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 1, by = 0.01)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
plot(testAccu)
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 0.4, by = 0.01)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
# train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
# trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
plot(testAccu)
require(gbm)
set.seed(1)
shirinkages = seq(from = 0, to = 0.4, by = 0.01)
trainAccu = rep(NA, length(shirinkages))
testAccu = rep(NA, length(shirinkages))
counter = 1
for (s in shirinkages) {
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = s)
yhat.boost.array = predict(boost.realEstate, newdata = validateSet, n.trees = 1000, type = 'response')
yhat.boost = ifelse(yhat.boost.array[,1,1] > yhat.boost.array[,2,1], 0, 1)
train.correct.rate = sum(yhat.boost == trainSet$binQua) / length(trainSet$binQua)
test.correct.rate = sum(yhat.boost == validateSet$binQua) / length(validateSet$binQua)
trainAccu[counter] = train.correct.rate
testAccu[counter] = test.correct.rate
counter = counter + 1
}
plot(trainAccu)
plot(trainAccu. shirinkages)
plot(trainAccu, shirinkages)
plot(shirinkages, trainAccu)
plot(shirinkages, trainAccu, type = 'b')
plot(shirinkages, trainAccu, type = 'l')
par(mfrow = c(1, 2)
plot(shirinkages, trainAccu, type = 'l')
par(mfrow = c(1, 2))
plot(shirinkages, trainAccu, type = 'l')
plot(shirinkages, testAccu, type = 'l')
which.min(testAccu)
which.max(testAccu)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = shirinkages[best])
best = which.max(testAccu)
boost.realEstate = gbm(binQua ~ ., data = trainSet, distribution = "multinomial", n.trees = 1000, shrinkage = shirinkages[best])
summarise(boost.realEstate)
summarye(boost.realEstate)
summary(boost.realEstate)
